<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Customizable Snake Game</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #1a1a1a;
      color: white;
      font-family: Arial, sans-serif;
    }
    canvas {
      border: 1px solid white;
      background-color: #4d4d4d;
      display: none;
    }
    #menu {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.85);
      padding: 30px;
      border: 2px solid white;
      border-radius: 10px;
      z-index: 1;
    }
    #menu label {
      margin-top: 15px;
    }
    #menu input[type="number"] {
      margin-left: 10px;
      padding: 5px;
      width: 60px;
    }
    button {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: white;
      color: black;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      font-size: 16px;
    }
    button:hover {
      background-color: gray;
    }
    #score {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 24px;
      display: none;
    }
    #finalScore {
      margin-top: 20px;
      font-size: 18px;
      color: yellow;
    }
  </style>
</head>
<body>

  <div id="menu">
    <h2>Snake Game</h2>
    <label for="boardSize">
      Board Size (10 - 50):
      <input type="number" id="boardSize" value="25" min="10" max="50">
    </label>
    <label for="speed">
      Snake Speed (1 - 10):
      <input type="number" id="speed" value="5" min="1" max="10">
    </label>
    <label>
      <input type="checkbox" id="multipleApplesToggle"> Enable Multiple Apples
      <input type="number" id="appleCount" value="1" min="1" max="10" disabled>
    </label>
    <label>
      <input type="checkbox" id="obstacleToggle"> Enable Obstacles
      <input type="number" id="obstacleInterval" value="10" min="1" max="100" disabled> (Spawn every X seconds)
    </label>
    <label>
      <input type="checkbox" id="powerToggle"> Enable Power-ups
      <input type="number" id="powerInterval" value="15" min="1" max="100" disabled> (Spawn every X seconds)
    </label>
    <button onclick="startGame()">Start Game</button>
    <div id="finalScore"></div>
  </div>
  
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const scoreElement = document.getElementById('score');
    const finalScoreElement = document.getElementById('finalScore');

    let grid = 16;
    let count = 0;
    let snakeSpeed = 5;
    let snakeColor = '';
    let score = 0;
    let gameInterval;
    let obstacleIntervalId;
    let powerIntervalId;
    let isGameRunning = false;

    let snake, apples = [], obstacles = [], powers = [];

    const POWER_TYPES = {
      SPEED_UP: 0,
      SPEED_DOWN: 1,
      SCORE_UP: 2
    };

    function initGame(boardSize, appleCount) {
      canvas.width = boardSize * grid;
      canvas.height = boardSize * grid;
      
      snake = {
        x: Math.floor(boardSize / 2) * grid,
        y: Math.floor(boardSize / 2) * grid,
        dx: grid,
        dy: 0,
        cells: [],
        maxCells: 4
      };
      
      apples = [];
      for (let i = 0; i < appleCount; i++) {
        spawnApple();
      }
      
      obstacles = [];
      powers = [];
      snakeColor = getRandomSnakeColor();
      score = 0;
      updateScore();
    }

    function startGame() {
      if (isGameRunning) return;

      const boardSize = parseInt(document.getElementById('boardSize').value);
      const speedInput = parseInt(document.getElementById('speed').value);
      const multipleApplesToggle = document.getElementById('multipleApplesToggle').checked;
      const appleCount = multipleApplesToggle ? parseInt(document.getElementById('appleCount').value) : 1;
      const obstacleToggle = document.getElementById('obstacleToggle').checked;
      const obstacleInterval = obstacleToggle ? parseInt(document.getElementById('obstacleInterval').value) * 1000 : 0;
      const powerToggle = document.getElementById('powerToggle').checked;
      const powerInterval = powerToggle ? parseInt(document.getElementById('powerInterval').value) * 1000 : 0;

      snakeSpeed = 11 - speedInput;
      grid = Math.floor(400 / boardSize);
      if (400 % boardSize !== 0) {
        alert('Board size must evenly divide 400 for proper grid alignment.');
        return;
      }

      initGame(boardSize, appleCount);
      menu.style.display = 'none';
      canvas.style.display = 'block';
      scoreElement.style.display = 'block';
      gameInterval = setInterval(loop, snakeSpeed * 100);

      if (obstacleToggle) {
        obstacleIntervalId = setInterval(spawnObstacle, obstacleInterval);
      }
      
      if (powerToggle) {
        powerIntervalId = setInterval(spawnPower, powerInterval);
      }
      
      isGameRunning = true;
    }

    function spawnApple() {
      let newApple;
      do {
        newApple = {
          x: getRandomInt(0, canvas.width / grid) * grid,
          y: getRandomInt(0, canvas.height / grid) * grid,
          color: getRandomAppleColor()
        };
      } while (isOccupied(newApple.x, newApple.y));
      apples.push(newApple);
    }

    function spawnObstacle() {
      let newObstacle;
      do {
        newObstacle = {
          x: getRandomInt(0, canvas.width / grid) * grid,
          y: getRandomInt(0, canvas.height / grid) * grid,
          color: 'black'
        };
      } while (isOccupied(newObstacle.x, newObstacle.y));
      obstacles.push(newObstacle);
    }

    function spawnPower() {
      let newPower;
      do {
        newPower = {
          x: getRandomInt(0, canvas.width / grid) * grid,
          y: getRandomInt(0, canvas.height / grid) * grid,
          color: 'magenta',
          type: getRandomPowerType()
        };
      } while (isOccupied(newPower.x, newPower.y));
      powers.push(newPower);
    }

    function isOccupied(x, y) {
      for (let cell of snake.cells) {
        if (cell.x === x && cell.y === y) return true;
      }
      for (let apple of apples) {
        if (apple.x === x && apple.y === y) return true;
      }
      for (let obstacle of obstacles) {
        if (obstacle.x === x && obstacle.y === y) return true;
      }
      for (let power of powers) {
        if (power.x === x && power.y === y) return true;
      }
      return false;
    }

    function getRandomPowerType() {
      const types = [POWER_TYPES.SPEED_UP, POWER_TYPES.SPEED_DOWN, POWER_TYPES.SCORE_UP];
      return types[Math.floor(Math.random() * types.length)];
    }

    function getRandomAppleColor() {
      const appleColors = ['red', 'orange'];
      return appleColors[Math.floor(Math.random() * appleColors.length)];
    }

    function getRandomSnakeColor() {
      const snakeColors = ['teal', 'cyan'];
      return snakeColors[Math.floor(Math.random() * snakeColors.length)];
    }

    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min)) + min;
    }

    function updateScore() {
      scoreElement.innerHTML = 'Score: ' + score;
    }

    function loop() {
      if (++count < 1) {
        return;
      }
      count = 0;
      
      context.clearRect(0, 0, canvas.width, canvas.height);
      
      snake.x += snake.dx;
      snake.y += snake.dy;
      
           // Wrap the snake around the edges
      if (snake.x < 0) {
        snake.x = canvas.width - grid;
      } else if (snake.x >= canvas.width) {
        snake.x = 0;
      }

      if (snake.y < 0) {
        snake.y = canvas.height - grid;
      } else if (snake.y >= canvas.height) {
        snake.y = 0;
      }
      
      // Add new head to the snake
      snake.cells.unshift({ x: snake.x, y: snake.y });
      
      // Remove excess cells
      if (snake.cells.length > snake.maxCells) {
        snake.cells.pop();
      }
      
      // Draw obstacles
      obstacles.forEach(function (obstacle) {
        context.fillStyle = obstacle.color;
        context.fillRect(obstacle.x, obstacle.y, grid - 1, grid - 1);
        
        // Check collision with snake
        if (snake.x === obstacle.x && snake.y === obstacle.y) {
          gameOver();
        }
      });
      
      // Draw power-ups
      powers.forEach(function (power, index) {
        context.fillStyle = power.color;
        context.fillRect(power.x, power.y, grid - 1, grid - 1);
        context.fillStyle = 'white';
        context.font = `${grid - 6}px Arial`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(power.type, power.x + grid / 2, power.y + grid / 2);
        
        // Check collision with snake
        if (snake.x === power.x && snake.y === power.y) {
          applyPowerUp(power.type);
          powers.splice(index, 1); // Remove the power-up after it's eaten
        }
      });
      
      // Draw apples
      apples.forEach(function (apple) {
        context.fillStyle = apple.color;
        context.fillRect(apple.x, apple.y, grid - 1, grid - 1);
      });
      
      // Draw the snake
      context.fillStyle = snakeColor;
      snake.cells.forEach(function (cell) {
        context.fillRect(cell.x, cell.y, grid - 1, grid - 1);
        
        // Check collision with apples
        apples.forEach(function (apple, index) {
          if (cell.x === apple.x && cell.y === apple.y) {
            snake.maxCells++;
            score++;
            updateScore();
            apples.splice(index, 1);
            spawnApple();
          }
        });
        
        // Check collision with itself
        for (let i = 1; i < snake.cells.length; i++) {
          if (cell.x === snake.cells[i].x && cell.y === snake.cells[i].y) {
            gameOver();
          }
        }
      });
    }

    function applyPowerUp(type) {
      switch(type) {
        case POWER_TYPES.SPEED_UP:
          if (snakeSpeed > 1) {
            snakeSpeed--;
            clearInterval(gameInterval);
            gameInterval = setInterval(loop, snakeSpeed * 100);
          }
          break;
        case POWER_TYPES.SPEED_DOWN:
          if (snakeSpeed < 10) {
            snakeSpeed++;
            clearInterval(gameInterval);
            gameInterval = setInterval(loop, snakeSpeed * 100);
          }
          break;
        case POWER_TYPES.SCORE_UP:
          score += 5; // Increase score by 5
          updateScore();
          break;
      }
    }

    function gameOver() {
      clearInterval(gameInterval);
      clearInterval(obstacleIntervalId);
      clearInterval(powerIntervalId);
      isGameRunning = false;
      finalScoreElement.innerHTML = 'Final Score: ' + score;
      canvas.style.display = 'none';
      menu.style.display = 'flex';
      scoreElement.style.display = 'none';
    }

    document.addEventListener('keydown', function(e) {
      if (e.which === 37 && snake.dx === 0) { // Left arrow
        snake.dx = -grid;
        snake.dy = 0;
      } else if (e.which === 38 && snake.dy === 0) { // Up arrow
        snake.dy = -grid;
        snake.dx = 0;
      } else if (e.which === 39 && snake.dx === 0) { // Right arrow
        snake.dx = grid;
        snake.dy = 0;
      } else if (e.which === 40 && snake.dy === 0) { // Down arrow
        snake.dy = grid;
        snake.dx = 0;
      }
    });

    document.getElementById('multipleApplesToggle').addEventListener('change', function() {
      document.getElementById('appleCount').disabled = !this.checked;
    });

    document.getElementById('obstacleToggle').addEventListener('change', function() {
      document.getElementById('obstacleInterval').disabled = !this.checked;
    });

    document.getElementById('powerToggle').addEventListener('change', function() {
      document.getElementById('powerInterval').disabled = !this.checked;
    });
  </script>
</body>
</html>
