<!DOCTYPE html>
<html>
<head>
  <title>Advanced Customizable Snake Game</title>
  <meta charset="UTF-8">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #1a1a1a; /* Darker gray for background */
      color: white; /* White text for visibility */
      font-family: Arial, sans-serif;
    }

    canvas {
      border: 1px solid white;
      background-color: #4d4d4d; /* Lighter gray for board */
      display: none; /* Hidden initially */
    }

    #menu {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.85);
      padding: 30px;
      border: 2px solid white;
      border-radius: 10px;
      color: white; /* White text */
      z-index: 1;
    }

    #menu label {
      margin-top: 15px;
    }

    #menu input[type="number"] {
      margin-left: 10px;
      padding: 5px;
      width: 60px;
    }

    button {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: white;
      color: black;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      font-size: 16px;
    }

    button:hover {
      background-color: gray;
    }

    #score {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 24px;
      color: white;
      display: none;
    }

    #finalScore {
      margin-top: 20px;
      font-size: 18px;
      color: yellow;
    }
  </style>
</head>
<body>

  <!-- Start Menu -->
  <div id="menu">
    <h2>Snake Game</h2>
    
    <!-- Board Size -->
    <label for="boardSize">
      Board Size (10 - 50):
      <input type="number" id="boardSize" value="25" min="10" max="50">
    </label>
    
    <!-- Snake Speed -->
    <label for="speed">
      Snake Speed (1 - 10):
      <input type="number" id="speed" value="5" min="1" max="10">
    </label>
    
    <!-- Multiple Apples -->
    <label>
      <input type="checkbox" id="multipleApplesToggle" onclick="document.getElementById('appleCount').disabled = !this.checked;"> Enable Multiple Apples
      <input type="number" id="appleCount" value="1" min="1" max="10" disabled>
    </label>
    
    <!-- Power-ups -->
    <label>
      <input type="checkbox" id="powerToggle" onclick="document.getElementById('powerInterval').disabled = !this.checked;"> Enable Power-ups
      <input type="number" id="powerInterval" value="15" min="1" max="100" disabled> (Spawn every X seconds)
    </label>
    
    <button onclick="startGame()">Start Game</button>
    
    <!-- Final Score Display -->
    <div id="finalScore"></div>
  </div>
  
  <!-- Score Display -->
  <div id="score">Score: 0</div>
  
  <!-- Game Canvas -->
  <canvas id="game"></canvas>
  
  <script>
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const scoreElement = document.getElementById('score');
    const finalScoreElement = document.getElementById('finalScore');

    // Game Variables
    let grid = 16;
    let count = 0;
    let snakeSpeed = 5; // 1 (slowest) to 10 (fastest)
    let snakeColor = '';
    let score = 0;
    let gameInterval;
    let powerIntervalId;
    let isGameRunning = false;

    // Snake and Game Objects
    let snake, apples = [], powers = [];

    // Power-up Types
    const POWER_TYPES = {
      SPEED_UP: 0,
      SPEED_DOWN: 1,
      SCORE_UP: 2
    };

    // Initialize the game based on user settings
    function initGame(boardSize, appleCount) {
      // Set canvas size
      canvas.width = boardSize * grid;
      canvas.height = boardSize * grid;
      
      // Initialize snake in the center
      snake = {
        x: Math.floor(boardSize / 2) * grid,
        y: Math.floor(boardSize / 2) * grid,
        dx: grid, // Initially moving right
        dy: 0,
        cells: [],
        maxCells: 4
      };
      
      // Initialize apples
      apples = [];
      for (let i = 0; i < appleCount; i++) {
        spawnApple();
      }
      
      // Initialize powers
      powers = [];
      
      // Choose snake color once
      snakeColor = getRandomSnakeColor();
      
      // Reset score
      score = 0;
      updateScore();
    }

    // Start the game
    function startGame() {
      if (isGameRunning) return; // Prevent multiple game instances

      // Get user inputs
      const boardSize = parseInt(document.getElementById('boardSize').value);
      const speedInput = parseInt(document.getElementById('speed').value);
      const multipleApplesToggle = document.getElementById('multipleApplesToggle').checked;
      const appleCount = multipleApplesToggle ? parseInt(document.getElementById('appleCount').value) : 1;
      const powerToggle = document.getElementById('powerToggle').checked;
      const powerInterval = parseInt(document.getElementById('powerInterval').value) * 1000; // Convert to ms
      
      // Set snake speed (inverse relationship: higher input = faster snake)
      snakeSpeed = 11 - speedInput; // Range: 1 (fastest) to 10 (slowest)
      
      // Adjust grid size based on board size
      grid = Math.floor(400 / boardSize);
      if (400 % boardSize !== 0) {
        alert('Board size must evenly divide 400 for proper grid alignment.');
        return;
      }

      // Initialize game objects
      initGame(boardSize, appleCount);
      
      // Hide menu and show game canvas
      menu.style.display = 'none';
      canvas.style.display = 'block';
      scoreElement.style.display = 'block';
      
      // Start the game loop
      gameInterval = setInterval(loop, snakeSpeed * 100); // Adjust timing based on speed
      
      // Set up power-up spawning if enabled
      if (powerToggle) {
        powerIntervalId = setInterval(spawnPower, powerInterval);
      }
      
      isGameRunning = true;
    }

    // Spawn an apple at a random location not occupied by snake or other apples
    function spawnApple() {
      let newApple;
      do {
        newApple = {
          x: getRandomInt(0, canvas.width / grid) * grid,
          y: getRandomInt(0, canvas.height / grid) * grid,
          color: getRandomAppleColor()
        };
      } while (isOccupied(newApple.x, newApple.y));
      apples.push(newApple);
    }

    // Spawn a power-up at a random location not occupied by snake or apples
    function spawnPower() {
      let newPower;
      do {
        newPower = {
          x: getRandomInt(0, canvas.width / grid) * grid,
          y: getRandomInt(0, canvas.height / grid) * grid,
          color: 'magenta',
          type: getRandomPowerType()
        };
      } while (isOccupied(newPower.x, newPower.y));
      powers.push(newPower);
    }

    // Check if a position is occupied by snake or apples
    function isOccupied(x, y) {
      // Check snake
      for (let cell of snake.cells) {
        if (cell.x === x && cell.y === y) return true;
      }
      // Check apples
      for (let apple of apples) {
        if (apple.x === x && apple.y === y) return true;
      }
      // Check power-ups
      for (let power of powers) {
        if (power.x === x && power.y === y) return true;
      }
      return false;
    }

    // Get random power-up type
    function getRandomPowerType() {
      const types = [POWER_TYPES.SPEED_UP, POWER_TYPES.SPEED_DOWN, POWER_TYPES.SCORE_UP];
      return types[Math.floor(Math.random() * types.length)];
    }

    // Get random color for the apple
    function getRandomAppleColor() {
      const appleColors = ['red', 'green', 'yellow'];
      return appleColors[Math.floor(Math.random() * appleColors.length)];
    }

    // Get random snake color
    function getRandomSnakeColor() {
      const snakeColors = ['#00FF00', '#FF00FF', '#FFFF00', '#00FFFF', '#FF0000'];
      return snakeColors[Math.floor(Math.random() * snakeColors.length)];
    }

    // Get a random integer between min (inclusive) and max (exclusive)
    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min)) + min;
    }

    // Event listener for keyboard input
    document.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowUp':
        case 'w':
          if (snake.dy === 0) {
            snake.dx = 0;
            snake.dy = -grid;
          }
          break;
        case 'ArrowDown':
        case 's':
          if (snake.dy === 0) {
            snake.dx = 0;
            snake.dy = grid;
          }
          break;
        case 'ArrowLeft':
        case 'a':
          if (snake.dx === 0) {
            snake.dx = -grid;
            snake.dy = 0;
          }
          break;
        case 'ArrowRight':
        case 'd':
          if (snake.dx === 0) {
            snake.dx = grid;
            snake.dy = 0;
          }
          break;
      }
    });

    // Game loop
    function loop() {
      if (++count < 1) {
        return;
      }
      count = 0;

      context.clearRect(0, 0, canvas.width, canvas.height);

      // Move snake
      snake.x += snake.dx;
      snake.y += snake.dy;

      // Wrap snake position on edges
      if (snake.x < 0) snake.x = canvas.width - grid;
      else if (snake.x >= canvas.width) snake.x = 0;
      if (snake.y < 0) snake.y = canvas.height - grid;
      else if (snake.y >= canvas.height) snake.y = 0;

      // Check collision with apples
      apples.forEach((apple, index) => {
        if (snake.x === apple.x && snake.y === apple.y) {
          score += 10;
          updateScore();
          snake.maxCells++; // Grow snake
          apples.splice(index, 1); // Remove apple
          spawnApple(); // Spawn new apple
        }
      });

      // Check collision with power-ups
      powers.forEach((power, index) => {
        if (snake.x === power.x && snake.y === power.y) {
          applyPower(power.type);
          powers.splice(index, 1); // Remove power-up
        }
      });

      // Add new head to snake cells
      snake.cells.unshift({ x: snake.x, y: snake.y });

      // Limit snake cells to max length
      if (snake.cells.length > snake.maxCells) {
        snake.cells.pop();
      }

      // Check collision with itself
      for (let i = 1; i < snake.cells.length; i++) {
        if (snake.cells[i].x === snake.x && snake.cells[i].y === snake.y) {
          endGame();
        }
      }

      // Draw snake
      context.fillStyle = snakeColor;
      snake.cells.forEach((cell) => {
        context.fillRect(cell.x, cell.y, grid - 1, grid - 1);
      });

      // Draw apples
      apples.forEach(apple => {
        context.fillStyle = apple.color;
        context.fillRect(apple.x, apple.y, grid - 1, grid - 1);
      });

      // Draw power-ups
      powers.forEach(power => {
        context.fillStyle = power.color;
        context.fillRect(power.x, power.y, grid - 1, grid - 1);
        context.fillStyle = 'white'; // Draw type number
        context.font = '12px Arial';
        context.fillText(power.type, power.x + 4, power.y + 12); // Display power type
      });
    }

    // Apply power-up effects
    function applyPower(type) {
      switch (type) {
        case POWER_TYPES.SPEED_UP:
          snakeSpeed = Math.max(1, snakeSpeed - 1); // Increase speed
          clearInterval(gameInterval);
          gameInterval = setInterval(loop, snakeSpeed * 100);
          break;
        case POWER_TYPES.SPEED_DOWN:
          snakeSpeed = Math.min(10, snakeSpeed + 1); // Decrease speed
          clearInterval(gameInterval);
          gameInterval = setInterval(loop, snakeSpeed * 100);
          break;
        case POWER_TYPES.SCORE_UP:
          score += 50; // Bonus points
          updateScore();
          break;
      }
    }

    // Update score display
    function updateScore() {
      scoreElement.textContent = `Score: ${score}`;
    }

    // End the game
    function endGame() {
      clearInterval(gameInterval);
      clearInterval(powerIntervalId);
      isGameRunning = false;
      canvas.style.display = 'none';
      scoreElement.style.display = 'none';
      finalScoreElement.textContent = `Final Score: ${score}`;
      finalScoreElement.style.display = 'block';
      menu.style.display = 'flex'; // Show menu again
    }
  </script>
</body>
</html>
